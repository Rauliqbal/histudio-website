import {
  __commonJS,
  __toESM
} from "./chunk-TWLJ45QX.js";

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge2(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge2;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge2;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return target.propertyIsEnumerable(symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge2(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge2.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge2(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge2;
    module.exports = deepmerge_1;
  }
});

// node_modules/vue-meta/dist/vue-meta.esm.js
var import_deepmerge = __toESM(require_cjs());
var version = "2.4.0";
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function() {
      };
      return {
        s: F,
        n: function() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function(e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it = o[Symbol.iterator]();
    },
    n: function() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(e) {
      didErr = true;
      err = e;
    },
    f: function() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
function isArray(arg) {
  return Array.isArray(arg);
}
function isUndefined(arg) {
  return typeof arg === "undefined";
}
function isObject(arg) {
  return _typeof(arg) === "object";
}
function isPureObject(arg) {
  return _typeof(arg) === "object" && arg !== null;
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isString(arg) {
  return typeof arg === "string";
}
function hasGlobalWindowFn() {
  try {
    return !isUndefined(window);
  } catch (e) {
    return false;
  }
}
var hasGlobalWindow = hasGlobalWindowFn();
var _global = hasGlobalWindow ? window : global;
var console = _global.console || {};
function warn(str) {
  if (!console || !console.warn) {
    return;
  }
  console.warn(str);
}
var showWarningNotSupported = function showWarningNotSupported2() {
  return warn("This vue app/component has no vue-meta configuration");
};
var defaultInfo = {
  title: void 0,
  titleChunk: "",
  titleTemplate: "%s",
  htmlAttrs: {},
  bodyAttrs: {},
  headAttrs: {},
  base: [],
  link: [],
  meta: [],
  style: [],
  script: [],
  noscript: [],
  __dangerouslyDisableSanitizers: [],
  __dangerouslyDisableSanitizersByTagID: {}
};
var rootConfigKey = "_vueMeta";
var keyName = "metaInfo";
var attribute = "data-vue-meta";
var ssrAttribute = "data-vue-meta-server-rendered";
var tagIDKeyName = "vmid";
var metaTemplateKeyName = "template";
var contentKeyName = "content";
var ssrAppId = "ssr";
var debounceWait = 10;
var waitOnDestroyed = true;
var defaultOptions = {
  keyName,
  attribute,
  ssrAttribute,
  tagIDKeyName,
  contentKeyName,
  metaTemplateKeyName,
  waitOnDestroyed,
  debounceWait,
  ssrAppId
};
var defaultInfoKeys = Object.keys(defaultInfo);
var disableOptionKeys = [defaultInfoKeys[12], defaultInfoKeys[13]];
var metaInfoOptionKeys = [defaultInfoKeys[1], defaultInfoKeys[2], "changed"].concat(disableOptionKeys);
var metaInfoAttributeKeys = [defaultInfoKeys[3], defaultInfoKeys[4], defaultInfoKeys[5]];
var tagsSupportingOnload = ["link", "style", "script"];
var tagsWithoutEndTag = ["base", "meta", "link"];
var tagsWithInnerContent = ["noscript", "script", "style"];
var tagAttributeAsInnerContent = ["innerHTML", "cssText", "json"];
var tagProperties = ["once", "skip", "template"];
var commonDataAttributes = ["body", "pbody"];
var booleanHtmlAttributes = ["allowfullscreen", "amp", "amp-boilerplate", "async", "autofocus", "autoplay", "checked", "compact", "controls", "declare", "default", "defaultchecked", "defaultmuted", "defaultselected", "defer", "disabled", "enabled", "formnovalidate", "hidden", "indeterminate", "inert", "ismap", "itemscope", "loop", "multiple", "muted", "nohref", "noresize", "noshade", "novalidate", "nowrap", "open", "pauseonexit", "readonly", "required", "reversed", "scoped", "seamless", "selected", "sortable", "truespeed", "typemustmatch", "visible"];
var batchId = null;
function triggerUpdate(_ref, rootVm, hookName) {
  var debounceWait2 = _ref.debounceWait;
  if (!rootVm[rootConfigKey].initialized && (rootVm[rootConfigKey].initializing || hookName === "watcher")) {
    rootVm[rootConfigKey].initialized = null;
  }
  if (rootVm[rootConfigKey].initialized && !rootVm[rootConfigKey].pausing) {
    batchUpdate(function() {
      return void rootVm.$meta().refresh();
    }, debounceWait2);
  }
}
function batchUpdate(callback, timeout) {
  timeout = timeout === void 0 ? 10 : timeout;
  if (!timeout) {
    callback();
    return;
  }
  clearTimeout(batchId);
  batchId = setTimeout(function() {
    callback();
  }, timeout);
  return batchId;
}
function find(array, predicate, thisArg) {
  if (!Array.prototype.find) {
    for (var idx = 0; idx < array.length; idx++) {
      if (predicate.call(thisArg, array[idx], idx, array)) {
        return array[idx];
      }
    }
    return;
  }
  return array.find(predicate, thisArg);
}
function findIndex(array, predicate, thisArg) {
  if (!Array.prototype.findIndex) {
    for (var idx = 0; idx < array.length; idx++) {
      if (predicate.call(thisArg, array[idx], idx, array)) {
        return idx;
      }
    }
    return -1;
  }
  return array.findIndex(predicate, thisArg);
}
function toArray(arg) {
  if (!Array.from) {
    return Array.prototype.slice.call(arg);
  }
  return Array.from(arg);
}
function includes(array, value) {
  if (!Array.prototype.includes) {
    for (var idx in array) {
      if (array[idx] === value) {
        return true;
      }
    }
    return false;
  }
  return array.includes(value);
}
var querySelector = function querySelector2(arg, el) {
  return (el || document).querySelectorAll(arg);
};
function getTag(tags, tag) {
  if (!tags[tag]) {
    tags[tag] = document.getElementsByTagName(tag)[0];
  }
  return tags[tag];
}
function getElementsKey(_ref) {
  var body = _ref.body, pbody = _ref.pbody;
  return body ? "body" : pbody ? "pbody" : "head";
}
function queryElements(parentNode, _ref2, attributes) {
  var appId2 = _ref2.appId, attribute2 = _ref2.attribute, type = _ref2.type, tagIDKeyName2 = _ref2.tagIDKeyName;
  attributes = attributes || {};
  var queries = ["".concat(type, "[").concat(attribute2, '="').concat(appId2, '"]'), "".concat(type, "[data-").concat(tagIDKeyName2, "]")].map(function(query) {
    for (var key in attributes) {
      var val = attributes[key];
      var attributeValue = val && val !== true ? '="'.concat(val, '"') : "";
      query += "[data-".concat(key).concat(attributeValue, "]");
    }
    return query;
  });
  return toArray(querySelector(queries.join(", "), parentNode));
}
function removeElementsByAppId(_ref3, appId2) {
  var attribute2 = _ref3.attribute;
  toArray(querySelector("[".concat(attribute2, '="').concat(appId2, '"]'))).map(function(el) {
    return el.remove();
  });
}
function removeAttribute(el, attributeName) {
  el.removeAttribute(attributeName);
}
function hasMetaInfo(vm) {
  vm = vm || this;
  return vm && (vm[rootConfigKey] === true || isObject(vm[rootConfigKey]));
}
function inMetaInfoBranch(vm) {
  vm = vm || this;
  return vm && !isUndefined(vm[rootConfigKey]);
}
function pause(rootVm, refresh2) {
  rootVm[rootConfigKey].pausing = true;
  return function() {
    return resume(rootVm, refresh2);
  };
}
function resume(rootVm, refresh2) {
  rootVm[rootConfigKey].pausing = false;
  if (refresh2 || refresh2 === void 0) {
    return rootVm.$meta().refresh();
  }
}
function addNavGuards(rootVm) {
  var router = rootVm.$router;
  if (rootVm[rootConfigKey].navGuards || !router) {
    return;
  }
  rootVm[rootConfigKey].navGuards = true;
  router.beforeEach(function(to, from, next) {
    pause(rootVm);
    next();
  });
  router.afterEach(function() {
    rootVm.$nextTick(function() {
      var _resume = resume(rootVm), metaInfo = _resume.metaInfo;
      if (metaInfo && isFunction(metaInfo.afterNavigation)) {
        metaInfo.afterNavigation(metaInfo);
      }
    });
  });
}
var appId = 1;
function createMixin(Vue, options) {
  var updateOnLifecycleHook = ["activated", "deactivated", "beforeMount"];
  var wasServerRendered = false;
  return {
    beforeCreate: function beforeCreate() {
      var _this2 = this;
      var rootKey = "$root";
      var $root = this[rootKey];
      var $options = this.$options;
      var devtoolsEnabled = Vue.config.devtools;
      Object.defineProperty(this, "_hasMetaInfo", {
        configurable: true,
        get: function get() {
          if (devtoolsEnabled && !$root[rootConfigKey].deprecationWarningShown) {
            warn("VueMeta DeprecationWarning: _hasMetaInfo has been deprecated and will be removed in a future version. Please use hasMetaInfo(vm) instead");
            $root[rootConfigKey].deprecationWarningShown = true;
          }
          return hasMetaInfo(this);
        }
      });
      if (this === $root) {
        $root.$once("hook:beforeMount", function() {
          wasServerRendered = this.$el && this.$el.nodeType === 1 && this.$el.hasAttribute("data-server-rendered");
          if (!wasServerRendered && $root[rootConfigKey] && $root[rootConfigKey].appId === 1) {
            var htmlTag = getTag({}, "html");
            wasServerRendered = htmlTag && htmlTag.hasAttribute(options.ssrAttribute);
          }
        });
      }
      if (isUndefined($options[options.keyName]) || $options[options.keyName] === null) {
        return;
      }
      if (!$root[rootConfigKey]) {
        $root[rootConfigKey] = {
          appId
        };
        appId++;
        if (devtoolsEnabled && $root.$options[options.keyName]) {
          this.$nextTick(function() {
            var child = find($root.$children, function(c) {
              return c.$vnode && c.$vnode.fnOptions;
            });
            if (child && child.$vnode.fnOptions[options.keyName]) {
              warn("VueMeta has detected a possible global mixin which adds a ".concat(options.keyName, " property to all Vue components on the page. This could cause severe performance issues. If possible, use $meta().addApp to add meta information instead"));
            }
          });
        }
      }
      if (!this[rootConfigKey]) {
        this[rootConfigKey] = true;
        var parent = this.$parent;
        while (parent && parent !== $root) {
          if (isUndefined(parent[rootConfigKey])) {
            parent[rootConfigKey] = false;
          }
          parent = parent.$parent;
        }
      }
      if (isFunction($options[options.keyName])) {
        $options.computed = $options.computed || {};
        $options.computed.$metaInfo = $options[options.keyName];
        if (!this.$isServer) {
          this.$on("hook:created", function() {
            this.$watch("$metaInfo", function() {
              triggerUpdate(options, this[rootKey], "watcher");
            });
          });
        }
      }
      if (isUndefined($root[rootConfigKey].initialized)) {
        $root[rootConfigKey].initialized = this.$isServer;
        if (!$root[rootConfigKey].initialized) {
          if (!$root[rootConfigKey].initializedSsr) {
            $root[rootConfigKey].initializedSsr = true;
            this.$on("hook:beforeMount", function() {
              var $root2 = this[rootKey];
              if (wasServerRendered) {
                $root2[rootConfigKey].appId = options.ssrAppId;
              }
            });
          }
          this.$on("hook:mounted", function() {
            var $root2 = this[rootKey];
            if ($root2[rootConfigKey].initialized) {
              return;
            }
            $root2[rootConfigKey].initializing = true;
            this.$nextTick(function() {
              var _$root$$meta$refresh = $root2.$meta().refresh(), tags = _$root$$meta$refresh.tags, metaInfo = _$root$$meta$refresh.metaInfo;
              if (tags === false && $root2[rootConfigKey].initialized === null) {
                this.$nextTick(function() {
                  return triggerUpdate(options, $root2, "init");
                });
              }
              $root2[rootConfigKey].initialized = true;
              delete $root2[rootConfigKey].initializing;
              if (!options.refreshOnceOnNavigation && metaInfo.afterNavigation) {
                addNavGuards($root2);
              }
            });
          });
          if (options.refreshOnceOnNavigation) {
            addNavGuards($root);
          }
        }
      }
      this.$on("hook:destroyed", function() {
        var _this = this;
        if (!this.$parent || !hasMetaInfo(this)) {
          return;
        }
        delete this._hasMetaInfo;
        this.$nextTick(function() {
          if (!options.waitOnDestroyed || !_this.$el || !_this.$el.offsetParent) {
            triggerUpdate(options, _this.$root, "destroyed");
            return;
          }
          var interval = setInterval(function() {
            if (_this.$el && _this.$el.offsetParent !== null) {
              return;
            }
            clearInterval(interval);
            triggerUpdate(options, _this.$root, "destroyed");
          }, 50);
        });
      });
      if (this.$isServer) {
        return;
      }
      updateOnLifecycleHook.forEach(function(lifecycleHook) {
        _this2.$on("hook:".concat(lifecycleHook), function() {
          triggerUpdate(options, this[rootKey], lifecycleHook);
        });
      });
    }
  };
}
function setOptions(options) {
  options = isObject(options) ? options : {};
  return {
    keyName: options["keyName"] || defaultOptions.keyName,
    attribute: options["attribute"] || defaultOptions.attribute,
    ssrAttribute: options["ssrAttribute"] || defaultOptions.ssrAttribute,
    tagIDKeyName: options["tagIDKeyName"] || defaultOptions.tagIDKeyName,
    contentKeyName: options["contentKeyName"] || defaultOptions.contentKeyName,
    metaTemplateKeyName: options["metaTemplateKeyName"] || defaultOptions.metaTemplateKeyName,
    debounceWait: isUndefined(options["debounceWait"]) ? defaultOptions.debounceWait : options["debounceWait"],
    waitOnDestroyed: isUndefined(options["waitOnDestroyed"]) ? defaultOptions.waitOnDestroyed : options["waitOnDestroyed"],
    ssrAppId: options["ssrAppId"] || defaultOptions.ssrAppId,
    refreshOnceOnNavigation: !!options["refreshOnceOnNavigation"]
  };
}
function getOptions(options) {
  var optionsCopy = {};
  for (var key in options) {
    optionsCopy[key] = options[key];
  }
  return optionsCopy;
}
function ensureIsArray(arg, key) {
  if (!key || !isObject(arg)) {
    return isArray(arg) ? arg : [];
  }
  if (!isArray(arg[key])) {
    arg[key] = [];
  }
  return arg;
}
var serverSequences = [[/&/g, "&amp;"], [/</g, "&lt;"], [/>/g, "&gt;"], [/"/g, "&quot;"], [/'/g, "&#x27;"]];
var clientSequences = [[/&/g, "&"], [/</g, "<"], [/>/g, ">"], [/"/g, '"'], [/'/g, "'"]];
function escape(info, options, escapeOptions, escapeKeys) {
  var tagIDKeyName2 = options.tagIDKeyName;
  var _escapeOptions$doEsca = escapeOptions.doEscape, doEscape = _escapeOptions$doEsca === void 0 ? function(v) {
    return v;
  } : _escapeOptions$doEsca;
  var escaped = {};
  for (var key in info) {
    var value = info[key];
    if (includes(metaInfoOptionKeys, key)) {
      escaped[key] = value;
      continue;
    }
    var disableKey = disableOptionKeys[0];
    if (escapeOptions[disableKey] && includes(escapeOptions[disableKey], key)) {
      escaped[key] = value;
      continue;
    }
    var tagId = info[tagIDKeyName2];
    if (tagId) {
      disableKey = disableOptionKeys[1];
      if (escapeOptions[disableKey] && escapeOptions[disableKey][tagId] && includes(escapeOptions[disableKey][tagId], key)) {
        escaped[key] = value;
        continue;
      }
    }
    if (isString(value)) {
      escaped[key] = doEscape(value);
    } else if (isArray(value)) {
      escaped[key] = value.map(function(v) {
        if (isPureObject(v)) {
          return escape(v, options, escapeOptions, true);
        }
        return doEscape(v);
      });
    } else if (isPureObject(value)) {
      escaped[key] = escape(value, options, escapeOptions, true);
    } else {
      escaped[key] = value;
    }
    if (escapeKeys) {
      var escapedKey = doEscape(key);
      if (key !== escapedKey) {
        escaped[escapedKey] = escaped[key];
        delete escaped[key];
      }
    }
  }
  return escaped;
}
function escapeMetaInfo(options, info, escapeSequences) {
  escapeSequences = escapeSequences || [];
  var escapeOptions = {
    doEscape: function doEscape(value) {
      return escapeSequences.reduce(function(val, seq) {
        return val.replace(seq[0], seq[1]);
      }, value);
    }
  };
  disableOptionKeys.forEach(function(disableKey, index2) {
    if (index2 === 0) {
      ensureIsArray(info, disableKey);
    } else if (index2 === 1) {
      for (var key in info[disableKey]) {
        ensureIsArray(info[disableKey], key);
      }
    }
    escapeOptions[disableKey] = info[disableKey];
  });
  return escape(info, options, escapeOptions);
}
function applyTemplate(_ref, headObject, template, chunk) {
  var component = _ref.component, metaTemplateKeyName2 = _ref.metaTemplateKeyName, contentKeyName2 = _ref.contentKeyName;
  if (template === true || headObject[metaTemplateKeyName2] === true) {
    return false;
  }
  if (isUndefined(template) && headObject[metaTemplateKeyName2]) {
    template = headObject[metaTemplateKeyName2];
    headObject[metaTemplateKeyName2] = true;
  }
  if (!template) {
    delete headObject[metaTemplateKeyName2];
    return false;
  }
  if (isUndefined(chunk)) {
    chunk = headObject[contentKeyName2];
  }
  headObject[contentKeyName2] = isFunction(template) ? template.call(component, chunk) : template.replace(/%s/g, chunk);
  return true;
}
function _arrayMerge(_ref, target, source) {
  var component = _ref.component, tagIDKeyName2 = _ref.tagIDKeyName, metaTemplateKeyName2 = _ref.metaTemplateKeyName, contentKeyName2 = _ref.contentKeyName;
  var destination = [];
  if (!target.length && !source.length) {
    return destination;
  }
  target.forEach(function(targetItem, targetIndex) {
    if (!targetItem[tagIDKeyName2]) {
      destination.push(targetItem);
      return;
    }
    var sourceIndex = findIndex(source, function(item) {
      return item[tagIDKeyName2] === targetItem[tagIDKeyName2];
    });
    var sourceItem = source[sourceIndex];
    if (sourceIndex === -1) {
      destination.push(targetItem);
      return;
    }
    if (contentKeyName2 in sourceItem && sourceItem[contentKeyName2] === void 0 || "innerHTML" in sourceItem && sourceItem.innerHTML === void 0) {
      destination.push(targetItem);
      source.splice(sourceIndex, 1);
      return;
    }
    if (sourceItem[contentKeyName2] === null || sourceItem.innerHTML === null) {
      source.splice(sourceIndex, 1);
      return;
    }
    var targetTemplate = targetItem[metaTemplateKeyName2];
    if (!targetTemplate) {
      return;
    }
    var sourceTemplate = sourceItem[metaTemplateKeyName2];
    if (!sourceTemplate) {
      applyTemplate({
        component,
        metaTemplateKeyName: metaTemplateKeyName2,
        contentKeyName: contentKeyName2
      }, sourceItem, targetTemplate);
      sourceItem.template = true;
      return;
    }
    if (!sourceItem[contentKeyName2]) {
      applyTemplate({
        component,
        metaTemplateKeyName: metaTemplateKeyName2,
        contentKeyName: contentKeyName2
      }, sourceItem, void 0, targetItem[contentKeyName2]);
    }
  });
  return destination.concat(source);
}
var warningShown = false;
function merge(target, source, options) {
  options = options || {};
  if (source.title === void 0) {
    delete source.title;
  }
  metaInfoAttributeKeys.forEach(function(attrKey) {
    if (!source[attrKey]) {
      return;
    }
    for (var key in source[attrKey]) {
      if (key in source[attrKey] && source[attrKey][key] === void 0) {
        if (includes(booleanHtmlAttributes, key) && !warningShown) {
          warn("VueMeta: Please note that since v2 the value undefined is not used to indicate boolean attributes anymore, see migration guide for details");
          warningShown = true;
        }
        delete source[attrKey][key];
      }
    }
  });
  return (0, import_deepmerge.default)(target, source, {
    arrayMerge: function arrayMerge(t, s) {
      return _arrayMerge(options, t, s);
    }
  });
}
function getComponentMetaInfo(options, component) {
  return getComponentOption(options || {}, component, defaultInfo);
}
function getComponentOption(options, component, result) {
  result = result || {};
  if (component._inactive) {
    return result;
  }
  options = options || {};
  var _options = options, keyName2 = _options.keyName;
  var $metaInfo = component.$metaInfo, $options = component.$options, $children = component.$children;
  if ($options[keyName2]) {
    var data = $metaInfo || $options[keyName2];
    if (isObject(data)) {
      result = merge(result, data, options);
    }
  }
  if ($children.length) {
    $children.forEach(function(childComponent) {
      if (!inMetaInfoBranch(childComponent)) {
        return;
      }
      result = getComponentOption(options, childComponent, result);
    });
  }
  return result;
}
var callbacks = [];
function isDOMComplete(d) {
  return (d || document).readyState === "complete";
}
function addCallback(query, callback) {
  if (arguments.length === 1) {
    callback = query;
    query = "";
  }
  callbacks.push([query, callback]);
}
function addCallbacks(_ref, type, tags, autoAddListeners) {
  var tagIDKeyName2 = _ref.tagIDKeyName;
  var hasAsyncCallback = false;
  tags.forEach(function(tag) {
    if (!tag[tagIDKeyName2] || !tag.callback) {
      return;
    }
    hasAsyncCallback = true;
    addCallback("".concat(type, "[data-").concat(tagIDKeyName2, '="').concat(tag[tagIDKeyName2], '"]'), tag.callback);
  });
  if (!autoAddListeners || !hasAsyncCallback) {
    return hasAsyncCallback;
  }
  return addListeners();
}
function addListeners() {
  if (isDOMComplete()) {
    applyCallbacks();
    return;
  }
  document.onreadystatechange = function() {
    applyCallbacks();
  };
}
function applyCallbacks(matchElement) {
  callbacks.forEach(function(args) {
    var query = args[0];
    var callback = args[1];
    var selector = "".concat(query, '[onload="this.__vm_l=1"]');
    var elements = [];
    if (!matchElement) {
      elements = toArray(querySelector(selector));
    }
    if (matchElement && matchElement.matches(selector)) {
      elements = [matchElement];
    }
    elements.forEach(function(element) {
      if (element.__vm_cb) {
        return;
      }
      var onload = function onload2() {
        element.__vm_cb = true;
        removeAttribute(element, "onload");
        callback(element);
      };
      if (element.__vm_l) {
        onload();
        return;
      }
      if (!element.__vm_ev) {
        element.__vm_ev = true;
        element.addEventListener("load", onload);
      }
    });
  });
}
var attributeMap = {};
function updateAttribute(appId2, options, type, attrs, tag) {
  var _ref = options || {}, attribute2 = _ref.attribute;
  var vueMetaAttrString = tag.getAttribute(attribute2);
  if (vueMetaAttrString) {
    attributeMap[type] = JSON.parse(decodeURI(vueMetaAttrString));
    removeAttribute(tag, attribute2);
  }
  var data = attributeMap[type] || {};
  var toUpdate = [];
  for (var attr in data) {
    if (data[attr] !== void 0 && appId2 in data[attr]) {
      toUpdate.push(attr);
      if (!attrs[attr]) {
        delete data[attr][appId2];
      }
    }
  }
  for (var _attr in attrs) {
    var attrData = data[_attr];
    if (!attrData || attrData[appId2] !== attrs[_attr]) {
      toUpdate.push(_attr);
      if (attrs[_attr] !== void 0) {
        data[_attr] = data[_attr] || {};
        data[_attr][appId2] = attrs[_attr];
      }
    }
  }
  for (var _i = 0, _toUpdate = toUpdate; _i < _toUpdate.length; _i++) {
    var _attr2 = _toUpdate[_i];
    var _attrData = data[_attr2];
    var attrValues = [];
    for (var _appId in _attrData) {
      Array.prototype.push.apply(attrValues, [].concat(_attrData[_appId]));
    }
    if (attrValues.length) {
      var attrValue = includes(booleanHtmlAttributes, _attr2) && attrValues.some(Boolean) ? "" : attrValues.filter(function(v) {
        return v !== void 0;
      }).join(" ");
      tag.setAttribute(_attr2, attrValue);
    } else {
      removeAttribute(tag, _attr2);
    }
  }
  attributeMap[type] = data;
}
function updateTitle(title) {
  if (!title && title !== "") {
    return;
  }
  document.title = title;
}
function updateTag(appId2, options, type, tags, head, body) {
  var _ref = options || {}, attribute2 = _ref.attribute, tagIDKeyName2 = _ref.tagIDKeyName;
  var dataAttributes = commonDataAttributes.slice();
  dataAttributes.push(tagIDKeyName2);
  var newElements = [];
  var queryOptions = {
    appId: appId2,
    attribute: attribute2,
    type,
    tagIDKeyName: tagIDKeyName2
  };
  var currentElements = {
    head: queryElements(head, queryOptions),
    pbody: queryElements(body, queryOptions, {
      pbody: true
    }),
    body: queryElements(body, queryOptions, {
      body: true
    })
  };
  if (tags.length > 1) {
    var found = [];
    tags = tags.filter(function(x) {
      var k = JSON.stringify(x);
      var res = !includes(found, k);
      found.push(k);
      return res;
    });
  }
  tags.forEach(function(tag) {
    if (tag.skip) {
      return;
    }
    var newElement = document.createElement(type);
    if (!tag.once) {
      newElement.setAttribute(attribute2, appId2);
    }
    Object.keys(tag).forEach(function(attr) {
      if (includes(tagProperties, attr)) {
        return;
      }
      if (attr === "innerHTML") {
        newElement.innerHTML = tag.innerHTML;
        return;
      }
      if (attr === "json") {
        newElement.innerHTML = JSON.stringify(tag.json);
        return;
      }
      if (attr === "cssText") {
        if (newElement.styleSheet) {
          newElement.styleSheet.cssText = tag.cssText;
        } else {
          newElement.appendChild(document.createTextNode(tag.cssText));
        }
        return;
      }
      if (attr === "callback") {
        newElement.onload = function() {
          return tag[attr](newElement);
        };
        return;
      }
      var _attr = includes(dataAttributes, attr) ? "data-".concat(attr) : attr;
      var isBooleanAttribute = includes(booleanHtmlAttributes, attr);
      if (isBooleanAttribute && !tag[attr]) {
        return;
      }
      var value = isBooleanAttribute ? "" : tag[attr];
      newElement.setAttribute(_attr, value);
    });
    var oldElements2 = currentElements[getElementsKey(tag)];
    var indexToDelete;
    var hasEqualElement = oldElements2.some(function(existingTag, index2) {
      indexToDelete = index2;
      return newElement.isEqualNode(existingTag);
    });
    if (hasEqualElement && (indexToDelete || indexToDelete === 0)) {
      oldElements2.splice(indexToDelete, 1);
    } else {
      newElements.push(newElement);
    }
  });
  var oldElements = [];
  for (var _type in currentElements) {
    Array.prototype.push.apply(oldElements, currentElements[_type]);
  }
  oldElements.forEach(function(element) {
    element.parentNode.removeChild(element);
  });
  newElements.forEach(function(element) {
    if (element.hasAttribute("data-body")) {
      body.appendChild(element);
      return;
    }
    if (element.hasAttribute("data-pbody")) {
      body.insertBefore(element, body.firstChild);
      return;
    }
    head.appendChild(element);
  });
  return {
    oldTags: oldElements,
    newTags: newElements
  };
}
function updateClientMetaInfo(appId2, options, newInfo) {
  options = options || {};
  var _options = options, ssrAttribute2 = _options.ssrAttribute, ssrAppId2 = _options.ssrAppId;
  var tags = {};
  var htmlTag = getTag(tags, "html");
  if (appId2 === ssrAppId2 && htmlTag.hasAttribute(ssrAttribute2)) {
    removeAttribute(htmlTag, ssrAttribute2);
    var addLoadListeners = false;
    tagsSupportingOnload.forEach(function(type2) {
      if (newInfo[type2] && addCallbacks(options, type2, newInfo[type2])) {
        addLoadListeners = true;
      }
    });
    if (addLoadListeners) {
      addListeners();
    }
    return false;
  }
  var tagsAdded = {};
  var tagsRemoved = {};
  for (var type in newInfo) {
    if (includes(metaInfoOptionKeys, type)) {
      continue;
    }
    if (type === "title") {
      updateTitle(newInfo.title);
      continue;
    }
    if (includes(metaInfoAttributeKeys, type)) {
      var tagName = type.substr(0, 4);
      updateAttribute(appId2, options, type, newInfo[type], getTag(tags, tagName));
      continue;
    }
    if (!isArray(newInfo[type])) {
      continue;
    }
    var _updateTag = updateTag(appId2, options, type, newInfo[type], getTag(tags, "head"), getTag(tags, "body")), oldTags = _updateTag.oldTags, newTags = _updateTag.newTags;
    if (newTags.length) {
      tagsAdded[type] = newTags;
      tagsRemoved[type] = oldTags;
    }
  }
  return {
    tagsAdded,
    tagsRemoved
  };
}
var appsMetaInfo;
function addApp(rootVm, appId2, options) {
  return {
    set: function set(metaInfo) {
      return setMetaInfo(rootVm, appId2, options, metaInfo);
    },
    remove: function remove() {
      return removeMetaInfo(rootVm, appId2, options);
    }
  };
}
function setMetaInfo(rootVm, appId2, options, metaInfo) {
  if (rootVm && rootVm.$el) {
    return updateClientMetaInfo(appId2, options, metaInfo);
  }
  appsMetaInfo = appsMetaInfo || {};
  appsMetaInfo[appId2] = metaInfo;
}
function removeMetaInfo(rootVm, appId2, options) {
  if (rootVm && rootVm.$el) {
    var tags = {};
    var _iterator = _createForOfIteratorHelper(metaInfoAttributeKeys), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var type = _step.value;
        var tagName = type.substr(0, 4);
        updateAttribute(appId2, options, type, {}, getTag(tags, tagName));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return removeElementsByAppId(options, appId2);
  }
  if (appsMetaInfo[appId2]) {
    delete appsMetaInfo[appId2];
    clearAppsMetaInfo();
  }
}
function getAppsMetaInfo() {
  return appsMetaInfo;
}
function clearAppsMetaInfo(force) {
  if (force || !Object.keys(appsMetaInfo).length) {
    appsMetaInfo = void 0;
  }
}
function getMetaInfo(options, info, escapeSequences, component) {
  options = options || {};
  escapeSequences = escapeSequences || [];
  var _options = options, tagIDKeyName2 = _options.tagIDKeyName;
  if (info.title) {
    info.titleChunk = info.title;
  }
  if (info.titleTemplate && info.titleTemplate !== "%s") {
    applyTemplate({
      component,
      contentKeyName: "title"
    }, info, info.titleTemplate, info.titleChunk || "");
  }
  if (info.base) {
    info.base = Object.keys(info.base).length ? [info.base] : [];
  }
  if (info.meta) {
    info.meta = info.meta.filter(function(metaItem, index2, arr) {
      var hasVmid = !!metaItem[tagIDKeyName2];
      if (!hasVmid) {
        return true;
      }
      var isFirstItemForVmid = index2 === findIndex(arr, function(item) {
        return item[tagIDKeyName2] === metaItem[tagIDKeyName2];
      });
      return isFirstItemForVmid;
    });
    info.meta.forEach(function(metaObject) {
      return applyTemplate(options, metaObject);
    });
  }
  return escapeMetaInfo(options, info, escapeSequences);
}
function refresh(rootVm, options) {
  options = options || {};
  if (!rootVm[rootConfigKey]) {
    showWarningNotSupported();
    return {};
  }
  var rawInfo = getComponentMetaInfo(options, rootVm);
  var metaInfo = getMetaInfo(options, rawInfo, clientSequences, rootVm);
  var appId2 = rootVm[rootConfigKey].appId;
  var tags = updateClientMetaInfo(appId2, options, metaInfo);
  if (tags && isFunction(metaInfo.changed)) {
    metaInfo.changed(metaInfo, tags.tagsAdded, tags.tagsRemoved);
    tags = {
      addedTags: tags.tagsAdded,
      removedTags: tags.tagsRemoved
    };
  }
  var appsMetaInfo2 = getAppsMetaInfo();
  if (appsMetaInfo2) {
    for (var additionalAppId in appsMetaInfo2) {
      updateClientMetaInfo(additionalAppId, options, appsMetaInfo2[additionalAppId]);
      delete appsMetaInfo2[additionalAppId];
    }
    clearAppsMetaInfo(true);
  }
  return {
    vm: rootVm,
    metaInfo,
    tags
  };
}
function attributeGenerator(options, type, data, _ref) {
  var addSsrAttribute = _ref.addSsrAttribute;
  var _ref2 = options || {}, attribute2 = _ref2.attribute, ssrAttribute2 = _ref2.ssrAttribute;
  var attributeStr = "";
  for (var attr in data) {
    var attrData = data[attr];
    var attrValues = [];
    for (var appId2 in attrData) {
      attrValues.push.apply(attrValues, _toConsumableArray([].concat(attrData[appId2])));
    }
    if (attrValues.length) {
      attributeStr += booleanHtmlAttributes.includes(attr) && attrValues.some(Boolean) ? "".concat(attr) : "".concat(attr, '="').concat(attrValues.join(" "), '"');
      attributeStr += " ";
    }
  }
  if (attributeStr) {
    attributeStr += "".concat(attribute2, '="').concat(encodeURI(JSON.stringify(data)), '"');
  }
  if (type === "htmlAttrs" && addSsrAttribute) {
    return "".concat(ssrAttribute2).concat(attributeStr ? " " : "").concat(attributeStr);
  }
  return attributeStr;
}
function titleGenerator(options, type, data, generatorOptions) {
  var _ref = generatorOptions || {}, ln = _ref.ln;
  if (!data) {
    return "";
  }
  return "<".concat(type, ">").concat(data, "</").concat(type, ">").concat(ln ? "\n" : "");
}
function tagGenerator(options, type, tags, generatorOptions) {
  var _ref = options || {}, ssrAppId2 = _ref.ssrAppId, attribute2 = _ref.attribute, tagIDKeyName2 = _ref.tagIDKeyName;
  var _ref2 = generatorOptions || {}, appId2 = _ref2.appId, _ref2$isSSR = _ref2.isSSR, isSSR = _ref2$isSSR === void 0 ? true : _ref2$isSSR, _ref2$body = _ref2.body, body = _ref2$body === void 0 ? false : _ref2$body, _ref2$pbody = _ref2.pbody, pbody = _ref2$pbody === void 0 ? false : _ref2$pbody, _ref2$ln = _ref2.ln, ln = _ref2$ln === void 0 ? false : _ref2$ln;
  var dataAttributes = [tagIDKeyName2].concat(_toConsumableArray(commonDataAttributes));
  if (!tags || !tags.length) {
    return "";
  }
  return tags.reduce(function(tagsStr, tag) {
    if (tag.skip) {
      return tagsStr;
    }
    var tagKeys = Object.keys(tag);
    if (tagKeys.length === 0) {
      return tagsStr;
    }
    if (Boolean(tag.body) !== body || Boolean(tag.pbody) !== pbody) {
      return tagsStr;
    }
    var attrs = tag.once ? "" : " ".concat(attribute2, '="').concat(appId2 || (isSSR === false ? "1" : ssrAppId2), '"');
    for (var attr in tag) {
      if (tagAttributeAsInnerContent.includes(attr) || tagProperties.includes(attr)) {
        continue;
      }
      if (attr === "callback") {
        attrs += ' onload="this.__vm_l=1"';
        continue;
      }
      var prefix = "";
      if (dataAttributes.includes(attr)) {
        prefix = "data-";
      }
      var isBooleanAttr = !prefix && booleanHtmlAttributes.includes(attr);
      if (isBooleanAttr && !tag[attr]) {
        continue;
      }
      attrs += " ".concat(prefix).concat(attr) + (isBooleanAttr ? "" : '="'.concat(tag[attr], '"'));
    }
    var json = "";
    if (tag.json) {
      json = JSON.stringify(tag.json);
    }
    var content = tag.innerHTML || tag.cssText || json;
    var hasEndTag = !tagsWithoutEndTag.includes(type);
    var hasContent = hasEndTag && tagsWithInnerContent.includes(type);
    return "".concat(tagsStr, "<").concat(type).concat(attrs).concat(!hasContent && hasEndTag ? "/" : "", ">") + (hasContent ? "".concat(content, "</").concat(type, ">") : "") + (ln ? "\n" : "");
  }, "");
}
function generateServerInjector(options, metaInfo, globalInjectOptions) {
  var serverInjector = {
    data: metaInfo,
    extraData: void 0,
    addInfo: function addInfo(appId2, metaInfo2) {
      this.extraData = this.extraData || {};
      this.extraData[appId2] = metaInfo2;
    },
    callInjectors: function callInjectors(opts) {
      var m = this.injectors;
      return (opts.body || opts.pbody ? "" : m.title.text(opts)) + m.meta.text(opts) + m.base.text(opts) + m.link.text(opts) + m.style.text(opts) + m.script.text(opts) + m.noscript.text(opts);
    },
    injectors: {
      head: function head(ln) {
        return serverInjector.callInjectors(_objectSpread2(_objectSpread2({}, globalInjectOptions), {}, {
          ln
        }));
      },
      bodyPrepend: function bodyPrepend(ln) {
        return serverInjector.callInjectors(_objectSpread2(_objectSpread2({}, globalInjectOptions), {}, {
          ln,
          pbody: true
        }));
      },
      bodyAppend: function bodyAppend(ln) {
        return serverInjector.callInjectors(_objectSpread2(_objectSpread2({}, globalInjectOptions), {}, {
          ln,
          body: true
        }));
      }
    }
  };
  var _loop = function _loop2(type2) {
    if (metaInfoOptionKeys.includes(type2)) {
      return "continue";
    }
    serverInjector.injectors[type2] = {
      text: function text(injectOptions) {
        var addSsrAttribute = injectOptions === true;
        injectOptions = _objectSpread2(_objectSpread2({
          addSsrAttribute
        }, globalInjectOptions), injectOptions);
        if (type2 === "title") {
          return titleGenerator(options, type2, serverInjector.data[type2], injectOptions);
        }
        if (metaInfoAttributeKeys.includes(type2)) {
          var attributeData = {};
          var data = serverInjector.data[type2];
          if (data) {
            var appId2 = injectOptions.isSSR === false ? "1" : options.ssrAppId;
            for (var attr in data) {
              attributeData[attr] = _defineProperty({}, appId2, data[attr]);
            }
          }
          if (serverInjector.extraData) {
            for (var _appId in serverInjector.extraData) {
              var _data = serverInjector.extraData[_appId][type2];
              if (_data) {
                for (var _attr in _data) {
                  attributeData[_attr] = _objectSpread2(_objectSpread2({}, attributeData[_attr]), {}, _defineProperty({}, _appId, _data[_attr]));
                }
              }
            }
          }
          return attributeGenerator(options, type2, attributeData, injectOptions);
        }
        var str = tagGenerator(options, type2, serverInjector.data[type2], injectOptions);
        if (serverInjector.extraData) {
          for (var _appId2 in serverInjector.extraData) {
            var _data2 = serverInjector.extraData[_appId2][type2];
            var extraStr = tagGenerator(options, type2, _data2, _objectSpread2({
              appId: _appId2
            }, injectOptions));
            str = "".concat(str).concat(extraStr);
          }
        }
        return str;
      }
    };
  };
  for (var type in defaultInfo) {
    var _ret = _loop(type);
    if (_ret === "continue")
      continue;
  }
  return serverInjector;
}
function inject(rootVm, options, injectOptions) {
  if (!rootVm[rootConfigKey]) {
    showWarningNotSupported();
    return {};
  }
  var rawInfo = getComponentMetaInfo(options, rootVm);
  var metaInfo = getMetaInfo(options, rawInfo, serverSequences, rootVm);
  var serverInjector = generateServerInjector(options, metaInfo, injectOptions);
  var appsMetaInfo2 = getAppsMetaInfo();
  if (appsMetaInfo2) {
    for (var additionalAppId in appsMetaInfo2) {
      serverInjector.addInfo(additionalAppId, appsMetaInfo2[additionalAppId]);
      delete appsMetaInfo2[additionalAppId];
    }
    clearAppsMetaInfo(true);
  }
  return serverInjector.injectors;
}
function $meta(options) {
  options = options || {};
  var $root = this.$root;
  return {
    getOptions: function getOptions$1() {
      return getOptions(options);
    },
    setOptions: function setOptions2(newOptions) {
      var refreshNavKey = "refreshOnceOnNavigation";
      if (newOptions && newOptions[refreshNavKey]) {
        options.refreshOnceOnNavigation = !!newOptions[refreshNavKey];
        addNavGuards($root);
      }
      var debounceWaitKey = "debounceWait";
      if (newOptions && debounceWaitKey in newOptions) {
        var debounceWait2 = parseInt(newOptions[debounceWaitKey]);
        if (!isNaN(debounceWait2)) {
          options.debounceWait = debounceWait2;
        }
      }
      var waitOnDestroyedKey = "waitOnDestroyed";
      if (newOptions && waitOnDestroyedKey in newOptions) {
        options.waitOnDestroyed = !!newOptions[waitOnDestroyedKey];
      }
    },
    refresh: function refresh$1() {
      return refresh($root, options);
    },
    inject: function inject$1(injectOptions) {
      return inject($root, options, injectOptions);
    },
    pause: function pause$1() {
      return pause($root);
    },
    resume: function resume$1() {
      return resume($root);
    },
    addApp: function addApp$1(appId2) {
      return addApp($root, appId2, options);
    }
  };
}
function generate(rawInfo, options) {
  options = setOptions(options);
  var metaInfo = getMetaInfo(options, rawInfo, serverSequences);
  var serverInjector = generateServerInjector(options, metaInfo);
  return serverInjector.injectors;
}
function install(Vue, options) {
  if (Vue.__vuemeta_installed) {
    return;
  }
  Vue.__vuemeta_installed = true;
  options = setOptions(options);
  Vue.prototype.$meta = function() {
    return $meta.call(this, options);
  };
  Vue.mixin(createMixin(Vue, options));
}
var index = {
  version,
  install,
  generate: function generate$1(metaInfo, options) {
    return generate(metaInfo, options);
  },
  hasMetaInfo
};
var vue_meta_esm_default = index;

// dep:vue-meta
var vue_meta_default = vue_meta_esm_default;
export {
  vue_meta_default as default
};
/**
 * vue-meta v2.4.0
 * (c) 2020
 * - Declan de Wet
 * - SÃ©bastien Chopin (@Atinux)
 * - Pim (@pimlie)
 * - All the amazing contributors
 * @license MIT
 */
//# sourceMappingURL=vue-meta.js.map
